(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{649:function(e,t,a){"use strict";a.r(t);var r=a(47),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("Web 缓存减少了等待时间和网络流量，因此减少了显示资源表示形式所需的时间，通过复用以前获取的资源，可以显著提高网站和应用程序的性能。")]),e._v(" "),a("h2",{attrs:{id:"概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),a("p",[e._v("缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的 URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。")]),e._v(" "),a("h2",{attrs:{id:"缓存的好处"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存的好处"}},[e._v("#")]),e._v(" 缓存的好处")]),e._v(" "),a("ul",[a("li",[e._v("减少网络延迟，加快页面打开速度")]),e._v(" "),a("li",[e._v("减少网络带宽消耗")]),e._v(" "),a("li",[e._v("降低服务器压力")])]),e._v(" "),a("h2",{attrs:{id:"缓存种类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存种类"}},[e._v("#")]),e._v(" 缓存种类")]),e._v(" "),a("p",[e._v("缓存的种类有很多,其大致可归为两类："),a("strong",[e._v("私有与共享缓存")]),e._v("。")]),e._v(" "),a("p",[a("strong",[e._v("私有缓存")]),e._v("只能用于单独用户。你可能已经见过浏览器设置中的“缓存”选项。"),a("strong",[e._v("浏览器缓存")]),e._v("拥有用户通过 "),a("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/HTTP",target:"_blank",rel:"noopener noreferrer"}},[e._v("HTTP"),a("OutboundLink")],1),e._v(" 下载的所有文档。这些缓存为浏览过的文档提供向后/向前导航，保存网页，查看源码等功能，可以避免再次向服务器发起多余的请求。它同样可以提供缓存内容的离线浏览。")]),e._v(" "),a("p",[a("strong",[e._v("共享缓存")]),e._v("可以被多个用户使用。例如，ISP 或你所在的公司可能会架设一个 web 代理来作为本地网络基础的一部分提供给用户。这样热门的资源就会被重复使用，减少网络拥堵与延迟。")]),e._v(" "),a("p",[e._v("除此之外还有网关缓存、CDN、反向代理缓存和负载均衡器等部署在服务器上的缓存方式，为站点和 web 应用提供更好的稳定性、性能和扩展性。")]),e._v(" "),a("h2",{attrs:{id:"http缓存特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http缓存特点"}},[e._v("#")]),e._v(" HTTP缓存特点")]),e._v(" "),a("p",[e._v("HTTP 缓存不是必须的，但重用缓存的资源通常是必要的。然而常见的 HTTP 缓存只能存储 "),a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("GET")]),a("OutboundLink")],1),e._v(" 响应，对于其他类型的响应则无能为力。缓存的关键主要包括request method和目标URI（一般只有GET请求才会被缓存）。 普遍的缓存案例:")]),e._v(" "),a("ul",[a("li",[e._v("一个检索请求的成功响应: 对于 "),a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("GET")]),a("OutboundLink")],1),e._v("请求，响应状态码为："),a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("200")]),a("OutboundLink")],1),e._v("，则表示为成功。一个包含例如HTML文档，图片，或者文件的响应。")]),e._v(" "),a("li",[e._v("永久重定向: 响应状态码："),a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/301",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("301")]),a("OutboundLink")],1),e._v("。")]),e._v(" "),a("li",[e._v("错误响应: 响应状态码："),a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/404",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("404")]),a("OutboundLink")],1),e._v(" 的一个页面。")]),e._v(" "),a("li",[e._v("不完全的响应: 响应状态码 "),a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/206",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("206")]),a("OutboundLink")],1),e._v("，只返回局部的信息。")]),e._v(" "),a("li",[e._v("除了 "),a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("GET")]),a("OutboundLink")],1),e._v(" 请求外，如果匹配到作为一个已被定义的cache键名的响应。")])]),e._v(" "),a("h2",{attrs:{id:"浏览器缓存策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存策略"}},[e._v("#")]),e._v(" 浏览器缓存策略")]),e._v(" "),a("p",[e._v("HTTP 缓存主要是通过请求和响应报文头中的对应 Header 信息，来控制缓存的策略。")]),e._v(" "),a("p",[e._v("响应头中相关字段为Expires、Cache-Control、Last-Modified、Etag。")]),e._v(" "),a("p",[a("strong",[e._v("浏览器缓存")]),e._v("一般分为两类：强缓存（也称本地缓存）和协商缓存（也称弱缓存）。")]),e._v(" "),a("h5",{attrs:{id:"本地缓存阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#本地缓存阶段"}},[e._v("#")]),e._v(" 本地缓存阶段")]),e._v(" "),a("p",[e._v("浏览器发送请求前，会先去缓存里查看是否命中强缓存，如果命中，则直接从缓存中读取资源，不会发送请求到服务器。否则，进入下一步。")]),e._v(" "),a("h5",{attrs:{id:"协商缓存阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存阶段"}},[e._v("#")]),e._v(" 协商缓存阶段")]),e._v(" "),a("p",[e._v("当强缓存没有命中时，浏览器一定会向服务器发起请求。服务器会根据 Request Header 中的一些字段来判断是否命中协商缓存。如果命中，服务器会返回 304 响应，但是不会携带任何响应实体，只是告诉浏览器可以直接从浏览器缓存中获取这个资源。如果本地缓存和协商缓存都没有命中，则从直接从服务器加载资源。")]),e._v(" "),a("h2",{attrs:{id:"浏览器缓存机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存机制"}},[e._v("#")]),e._v(" 浏览器缓存机制")]),e._v(" "),a("h3",{attrs:{id:"强缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[e._v("#")]),e._v(" 强缓存")]),e._v(" "),a("h4",{attrs:{id:"expires"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[e._v("#")]),e._v(" Expires")]),e._v(" "),a("p",[e._v("response header里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强制缓存。")]),e._v(" "),a("h4",{attrs:{id:"cache-control"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[e._v("#")]),e._v(" Cache-Control")]),e._v(" "),a("p",[e._v("当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/305942/1588900617474-c5debfb6-4e89-4eca-afa8-7ee32d73e719.png",alt:"img"}})]),e._v(" "),a("h4",{attrs:{id:"expires和cache-control的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#expires和cache-control的区别"}},[e._v("#")]),e._v(" Expires和Cache-Control的区别")]),e._v(" "),a("ol",[a("li",[e._v("Expires 是http1.0的产物，Cache-Control是http1.1的产物")]),e._v(" "),a("li",[e._v("两者同时存在的话，Cache-Control优先级高于Expires；")]),e._v(" "),a("li",[e._v("在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法")]),e._v(" "),a("li",[e._v("Expires是一个具体的服务器时间，这就导致一个问题，如果客户端时间和服务器时间相差较大，缓存命中与否就不是开发者所期望的。Cache-Control是一个时间段，控制就比较容易")])]),e._v(" "),a("h3",{attrs:{id:"协商缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[e._v("#")]),e._v(" 协商缓存")]),e._v(" "),a("h4",{attrs:{id:"etag和if-none-match"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#etag和if-none-match"}},[e._v("#")]),e._v(" ETag和If-None-Match")]),e._v(" "),a("p",[e._v("这两个要一起说。Etag是上一次加载资源时，服务器返回的response header，是对该资源的一种唯一标识，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器接受到If-None-Match的值后，会拿来跟该资源文件的Etag值做比较，如果相同，则表示资源文件没有发生改变，命中协商缓存。")]),e._v(" "),a("h4",{attrs:{id:"last-modified和if-modified-since"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#last-modified和if-modified-since"}},[e._v("#")]),e._v(" Last-Modified和If-Modified-Since")]),e._v(" "),a("p",[e._v("这两个也要一起说。Last-Modified是该资源文件最后一次更改时间，服务器会在response header里返回，同时浏览器会将这个值保存起来，在下一次发送请求时，放到request header里的If-Modified-Since里，服务器在接收到后也会做比对，如果相同则命中协商缓存。")]),e._v(" "),a("h4",{attrs:{id:"etag和last-modified区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#etag和last-modified区别"}},[e._v("#")]),e._v(" ETag和Last-Modified区别")]),e._v(" "),a("ol",[a("li",[e._v("在方式上，Etag是对资源的一种唯一标识，而Last-Modified是该资源文件最后一次更改时间")]),e._v(" "),a("li",[e._v("在精确度上，Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。")]),e._v(" "),a("li",[e._v("在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。")]),e._v(" "),a("li",[e._v("在优先级上，服务器校验优先考虑Etag。")])]),e._v(" "),a("h2",{attrs:{id:"浏览器缓存过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存过程"}},[e._v("#")]),e._v(" 浏览器缓存过程")]),e._v(" "),a("ol",[a("li",[e._v("浏览器第一次加载资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，并把response header及该请求的返回时间一并缓存；")]),e._v(" "),a("li",[e._v("下一次加载资源时，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持HTTP1.1，则用expires判断是否过期）；如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求；")]),e._v(" "),a("li",[e._v("服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200；")]),e._v(" "),a("li",[e._v("如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200；")])]),e._v(" "),a("p",[e._v("用户访问行为会"),a("strong",[e._v("改变缓存控制")]),e._v("：")]),e._v(" "),a("ul",[a("li",[e._v("地址栏访问，链接跳转是正常用户行为，将会触发浏览器缓存机制；")]),e._v(" "),a("li",[e._v("F5刷新，浏览器会设置max-age=0，跳过强缓存判断，会进行协商缓存判断；")]),e._v(" "),a("li",[e._v("ctrl+F5刷新，跳过强缓存和协商缓存，直接从服务器拉取资源。")])]),e._v(" "),a("hr")])}),[],!1,null,null,null);t.default=s.exports}}]);