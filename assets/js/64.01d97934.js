(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{680:function(t,e,a){"use strict";a.r(e);var r=a(47),v=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("在浏览器中输入URL到整个页面显示在用户面前时这个过程中到底发生了什么。仔细思考这个问题，发现确实很深，这个过程涉及到的东西非常的多。")]),t._v(" "),a("h2",{attrs:{id:"过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#过程"}},[t._v("#")]),t._v(" 过程")]),t._v(" "),a("ul",[a("li",[t._v("URL输入")]),t._v(" "),a("li",[t._v("DNS解析")]),t._v(" "),a("li",[t._v("TCP连接")]),t._v(" "),a("li",[t._v("发送HTTP请求")]),t._v(" "),a("li",[t._v("服务器处理请求")]),t._v(" "),a("li",[t._v("服务器响应请求")]),t._v(" "),a("li",[t._v("浏览器解析渲染页面")]),t._v(" "),a("li",[t._v("连接结束")])]),t._v(" "),a("h2",{attrs:{id:"输入url"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#输入url"}},[t._v("#")]),t._v(" 输入URL")]),t._v(" "),a("blockquote",[a("p",[t._v("URL中文名叫做统一资源定位符，统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。")])]),t._v(" "),a("p",[a("strong",[t._v("主要组成部分：protocol 😕/ hostname[:port] / path / [;parameters][?query]#fragment")])]),t._v(" "),a("ul",[a("li",[t._v("protocol（协议）")]),t._v(" "),a("li",[t._v("hostname（主机名）")]),t._v(" "),a("li",[t._v("port（端口号）")]),t._v(" "),a("li",[t._v("path（路径）")]),t._v(" "),a("li",[t._v("parameters（参数）")]),t._v(" "),a("li",[t._v("query(查询)")]),t._v(" "),a("li",[t._v("fragment（信息片断）")])]),t._v(" "),a("p",[t._v("当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得 url 了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url，然后给出智能提示，让你可以补全url地址。对于 google的chrome 的浏览器，他甚至会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。")]),t._v(" "),a("h2",{attrs:{id:"dns解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dns解析"}},[t._v("#")]),t._v(" DNS解析")]),t._v(" "),a("blockquote",[a("p",[t._v("DNS解析的过程就是寻找哪台机器上有你需要资源的过程。当你在浏览器中输入一个地址时，例如www.baidu.com，其实不是百度网站真正意义上的地址。互联网上每一台计算机的唯一标识是它的IP地址，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，这个过程就是DNS解析。它实际上充当了一个翻译的角色，实现了网址到IP地址的转换。网址到IP地址转换的过程是如何进行的?")])]),t._v(" "),a("p",[a("strong",[t._v("查找顺序： 浏览器缓存--\x3e  操作系统缓存--\x3e 本地host文件 --\x3e 路由器缓存--\x3e ISP DNS缓存 --\x3e  顶级DNS服务器/根DNS服务器")])]),t._v(" "),a("p",[t._v("​\t1、"),a("strong",[t._v("浏览器缓存")]),t._v(" ：首先会向浏览器的缓存中读取上一次访问的记录，在chrome可以通过地址栏中输入chrome://net-internals/#dns查看缓存的当前状态 。")]),t._v(" "),a("p",[t._v("​\t2、"),a("strong",[t._v("操作系统缓存")]),t._v("： 查找存储在系统运行内存中的缓存。在mac中可以通过下面的命令清除系统中的DNS缓存。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("dscacheutil -flushcache\n复制代码\n")])])]),a("p",[t._v("​\t3、 **hosts 文件：**查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。")]),t._v(" "),a("p",[t._v("​\t4、"),a("strong",[t._v("路由器缓存")]),t._v("： 有些路由器也有DNS缓存的功能，访问过的域名会存在路由器上。")]),t._v(" "),a("p",[t._v("​\t5、"),a("strong",[t._v("ISP DNS缓存")]),t._v("：互联网服务提供商（如中国电信）也会提供DNS服务，比如比较著名的 114.114.114.114，在本地查找不到的情况下，就会向ISP进行查询，ISP会在当前服务器的缓存内查找是否有记录，如果有，则返回这个IP，若没有，则会开始向根域名服务器请求查询。")]),t._v(" "),a("p",[t._v("​\t6、"),a("strong",[t._v("顶级DNS服务器/根DNS服务器")]),t._v("：根域名收到请求后，会判别这个域名(.com)是授权给哪台服务器管理,并返回这个顶级DNS服务器的IP。请求者收到这台顶级DNS的服务器IP后，会向该服务器发起查询，如果该服务器无法解析，该服务器就会返回下一级的DNS服务器IP（nicefilm.com），本机继续查找，直到服务器找到(www.nicefilm.com)的主机。")]),t._v(" "),a("p",[t._v("​\t6、最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。")]),t._v(" "),a("p",[t._v("下面这张图很完美的解释了这一过程：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/4/163c83c423b021ca~tplv-t2oaga2asx-watermark.awebp",alt:"img"}}),t._v("optional title")]),t._v(" "),a("p",[t._v("上述图片是查找www.google.com的IP地址过程。首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从右向左的过程: com -> google.com -> www.google.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是www.google.com.，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为: . -> .com -> google.com. -> www.google.com.。")]),t._v(" "),a("p",[t._v("补充：")]),t._v(" "),a("ol",[a("li",[a("h4",{attrs:{id:"什么是dns"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是dns"}},[t._v("#")]),t._v(" 什么是DNS？")]),t._v(" "),a("p",[t._v("DNS（Domain Name System，域名系统），因特网上作为域名和"),a("a",{attrs:{href:"https://link.juejin.cn?target=http%3A%2F%2Fbaike.baidu.com%2Fitem%2FIP%E5%9C%B0%E5%9D%80",target:"_blank",rel:"noopener noreferrer"}},[t._v("IP地址"),a("OutboundLink")],1),t._v("相互映射的一个"),a("a",{attrs:{href:"https://link.juejin.cn?target=http%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93",target:"_blank",rel:"noopener noreferrer"}},[t._v("分布式数据库"),a("OutboundLink")],1),t._v("，能够使用户更方便的访问"),a("a",{attrs:{href:"https://link.juejin.cn?target=http%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E4%BA%92%E8%81%94%E7%BD%91",target:"_blank",rel:"noopener noreferrer"}},[t._v("互联网"),a("OutboundLink")],1),t._v("，而不用去记住能够被机器直接读取的IP数串。通过"),a("a",{attrs:{href:"https://link.juejin.cn?target=http%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E4%B8%BB%E6%9C%BA",target:"_blank",rel:"noopener noreferrer"}},[t._v("主机"),a("OutboundLink")],1),t._v("名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。")]),t._v(" "),a("p",[t._v("通俗的讲，我们更习惯于记住一个网站的名字，比如www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。而计算机更擅长记住网站的ip地址，而不是像www.baidu.com等链接。因为，DNS就相当于一个电话本，比如你要找www.baidu.com这个域名，那我翻一翻我的电话本，我就知道，哦，它的电话（ip）是167.23.10.2。")])]),t._v(" "),a("li",[a("h4",{attrs:{id:"dns查询的两种方式-递归查询和迭代查询"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dns查询的两种方式-递归查询和迭代查询"}},[t._v("#")]),t._v(" DNS查询的两种方式：递归查询和迭代查询")]),t._v(" "),a("p",[t._v("2.1、递归解析")]),t._v(" "),a("p",[t._v("​    当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式，如图所示的是递归方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/4/163c83c3e10e8cdc~tplv-t2oaga2asx-watermark.awebp",alt:"img"}})]),t._v(" "),a("p",[t._v("2.2、迭代解析")]),t._v(" "),a("p",[t._v("当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析，如图所示。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/4/163c83c3e16a7952~tplv-t2oaga2asx-watermark.awebp",alt:"img"}})])]),t._v(" "),a("li",[a("h4",{attrs:{id:"dns域名称空间的组织方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dns域名称空间的组织方式"}},[t._v("#")]),t._v(" DNS域名称空间的组织方式")]),t._v(" "),a("p",[t._v("我们在前面有说到根DNS服务器，域DNS服务器，这些都是DNS域名称空间的组织方式。按其功能命名空间中用来描述 DNS 域名称的五个类别的介绍详见下表中，以及与每个名称类型的示例")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/4/163c83c3ecf9f9a3~tplv-t2oaga2asx-watermark.awebp",alt:"img"}})])]),t._v(" "),a("li",[a("h4",{attrs:{id:"dns优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dns优化"}},[t._v("#")]),t._v(" DNS优化")]),t._v(" "),a("p",[t._v("了解了DNS的过程，可以为我们带来哪些？上文中请求到google的IP地址时，经历了8个步骤，这个过程中存在多个请求(同时存在UDP和TCP请求，为什么有两种请求方式，请自行查找)。如果每次都经过这么多步骤，是否太耗时间？如何减少该过程的步骤呢？那就是DNS缓存。")]),t._v(" "),a("p",[t._v("4.1 DNS缓存")]),t._v(" "),a("p",[t._v("DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。")]),t._v(" "),a("ul",[a("li",[t._v("在你的chrome浏览器中输入:chrome://dns/，你可以看到chrome浏览器的DNS缓存。")]),t._v(" "),a("li",[t._v("系统缓存主要存在/etc/hosts(Linux系统)中:")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/4/163c83c48f338efc~tplv-t2oaga2asx-watermark.awebp",alt:"DNS系统缓存"}})]),t._v(" "),a("p",[t._v("4.2 DNS负载均衡")]),t._v(" "),a("p",[t._v("当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。")])])]),t._v(" "),a("h2",{attrs:{id:"建立tcp连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#建立tcp连接"}},[t._v("#")]),t._v(" 建立TCP连接")]),t._v(" "),a("p",[t._v("拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024<端口<65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。")]),t._v(" "),a("p",[t._v("TCP连接如图所示:")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/4/163c83c3f1ee1fe3~tplv-t2oaga2asx-watermark.awebp",alt:"img"}})]),t._v(" "),a("h3",{attrs:{id:"三次握手以建立tcp连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三次握手以建立tcp连接"}},[t._v("#")]),t._v(" 三次握手以建立TCP连接")]),t._v(" "),a("p",[t._v("第一次握手：建立连接时，"),a("a",{attrs:{href:"https://link.juejin.cn?target=http%3A%2F%2Fbaike.baidu.com%2Fview%2F930.htm",target:"_blank",rel:"noopener noreferrer"}},[t._v("客户端"),a("OutboundLink")],1),t._v("发送"),a("a",{attrs:{href:"https://link.juejin.cn?target=http%3A%2F%2Fbaike.baidu.com%2Fview%2F488528.htm",target:"_blank",rel:"noopener noreferrer"}},[t._v("syn"),a("OutboundLink")],1),t._v("包（syn=j）到"),a("a",{attrs:{href:"https://link.juejin.cn?target=http%3A%2F%2Fbaike.baidu.com%2Fview%2F899.htm",target:"_blank",rel:"noopener noreferrer"}},[t._v("服务器"),a("OutboundLink")],1),t._v("，并进入"),a("a",{attrs:{href:"https://link.juejin.cn?target=http%3A%2F%2Fbaike.baidu.com%2Fview%2F840439.htm",target:"_blank",rel:"noopener noreferrer"}},[t._v("SYN_SENT"),a("OutboundLink")],1),t._v("状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://link.juejin.cn?target=http%3A%2F%2Fbaike.baidu.com%2Fview%2F205949.htm",target:"_blank",rel:"noopener noreferrer"}},[t._v("第二次握手"),a("OutboundLink")],1),t._v("："),a("a",{attrs:{href:"https://link.juejin.cn?target=http%3A%2F%2Fbaike.baidu.com%2Fview%2F899.htm",target:"_blank",rel:"noopener noreferrer"}},[t._v("服务器"),a("OutboundLink")],1),t._v("收到"),a("a",{attrs:{href:"https://link.juejin.cn?target=http%3A%2F%2Fbaike.baidu.com%2Fview%2F488528.htm",target:"_blank",rel:"noopener noreferrer"}},[t._v("syn"),a("OutboundLink")],1),t._v("包，必须确认客户的SYN（"),a("a",{attrs:{href:"https://link.juejin.cn?target=http%3A%2F%2Fbaike.baidu.com%2Fview%2F204040.htm",target:"_blank",rel:"noopener noreferrer"}},[t._v("ack"),a("OutboundLink")],1),t._v("=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入"),a("a",{attrs:{href:"https://link.juejin.cn?target=http%3A%2F%2Fbaike.baidu.com%2Fview%2F1520054.htm",target:"_blank",rel:"noopener noreferrer"}},[t._v("SYN_RECV"),a("OutboundLink")],1),t._v("状态；")]),t._v(" "),a("p",[t._v("第三次握手："),a("a",{attrs:{href:"https://link.juejin.cn?target=http%3A%2F%2Fbaike.baidu.com%2Fview%2F930.htm",target:"_blank",rel:"noopener noreferrer"}},[t._v("客户端"),a("OutboundLink")],1),t._v("收到"),a("a",{attrs:{href:"https://link.juejin.cn?target=http%3A%2F%2Fbaike.baidu.com%2Fview%2F133203.htm",target:"_blank",rel:"noopener noreferrer"}},[t._v("服务"),a("OutboundLink")],1),t._v("器的SYN+ACK包，向"),a("a",{attrs:{href:"https://link.juejin.cn?target=http%3A%2F%2Fbaike.baidu.com%2Fview%2F899.htm",target:"_blank",rel:"noopener noreferrer"}},[t._v("服务器"),a("OutboundLink")],1),t._v("发送确认包ACK("),a("a",{attrs:{href:"https://link.juejin.cn?target=http%3A%2F%2Fbaike.baidu.com%2Fview%2F204040.htm",target:"_blank",rel:"noopener noreferrer"}},[t._v("ack"),a("OutboundLink")],1),t._v("=k+1），此包发送完毕，客户端和服务器进入"),a("a",{attrs:{href:"https://link.juejin.cn?target=http%3A%2F%2Fbaike.baidu.com%2Fview%2F1137549.htm",target:"_blank",rel:"noopener noreferrer"}},[t._v("ESTABLISHED"),a("OutboundLink")],1),t._v("（TCP连接成功）状态，完成三次握手。")]),t._v(" "),a("p",[t._v("补充：")]),t._v(" "),a("p",[a("strong",[t._v("为什需要三次握手？")])]),t._v(" "),a("p",[t._v("​\t《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”，书中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。")]),t._v(" "),a("h2",{attrs:{id:"发送http请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#发送http请求"}},[t._v("#")]),t._v(" 发送HTTP请求")]),t._v(" "),a("p",[t._v("建立了TCP连接之后，发起一个http请求。一个典型的 http request header 一般需要包括请求的方法，例如 GET 或者 POST 等，不常用的还有 PUT 和 DELETE 、HEAD、OPTION以及 TRACE 方法，一般的浏览器只能发起 GET 或者 POST 请求。")]),t._v(" "),a("p",[t._v("客户端向服务器发起http请求的时候，会有一些请求信息，请求信息包含三个部分：")]),t._v(" "),a("ul",[a("li",[t._v("请求方法URI协议/版本")]),t._v(" "),a("li",[t._v("请求头(Request Header)")]),t._v(" "),a("li",[t._v("请求正文：")])]),t._v(" "),a("p",[t._v("下面是一个完整的HTTP请求例子：")]),t._v(" "),a("div",{staticClass:"language-html extra-class"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[t._v("GET/sample.jspHTTP/1.1\nAccept:image/gif.image/jpeg,*/*\nAccept-Language:zh-cn\nConnection:Keep-Alive\nHost:localhost\nUser-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)\nAccept-Encoding:gzip,deflate\n\nusername=jinqiao&password=1234\n复制代码\n")])])]),a("p",[t._v("注意：最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。")]),t._v(" "),a("p",[t._v("（1）请求的第一行是“方法URL议/版本”："),a("code",[t._v("GET/sample.jsp HTTP/1.1")]),t._v(" （2）请求头(Request Header)   请求头包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明浏览器所用的语言，请求正文的长度等。")]),t._v(" "),a("div",{staticClass:"language-html extra-class"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[t._v("Accept:image/gif.image/jpeg.*/*\nAccept-Language:zh-cn\nConnection:Keep-Alive\nHost:localhost\nUser-Agent:Mozila/4.0(compatible:MSIE5.01:Windows NT5.0)\nAccept-Encoding:gzip,deflate.\n复制代码\n")])])]),a("p",[t._v("（3）请求正文 请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符串信息：")]),t._v(" "),a("div",{staticClass:"language-html extra-class"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[t._v("username=jinqiao&password=1234\n复制代码\n")])])]),a("h2",{attrs:{id:"服务器永久重定向"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务器永久重定向"}},[t._v("#")]),t._v(" 服务器永久重定向")]),t._v(" "),a("p",[t._v("​\t服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问"),a("code",[t._v("http://www.google.com/")]),t._v(" 而非"),a("code",[t._v("http://google.com/")]),t._v("。")]),t._v(" "),a("p",[t._v("​\t为什么服务器一定要重定向而不是直接发送用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像"),a("code",[t._v("http://www.yy.com/")]),t._v("和"),a("code",[t._v("http://yy.com/")]),t._v("，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。还有就是用不同的地址会造成缓存友好性变差，当一个页面有好几个名字时，它可能会在缓存里出现好几次。")]),t._v(" "),a("p",[t._v("补充：")]),t._v(" "),a("p",[a("strong",[t._v("1、301和302的区别：")])]),t._v(" "),a("p",[t._v("301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。  他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；  302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO302好于301")]),t._v(" "),a("p",[a("strong",[t._v("2、重定向原因：")])]),t._v(" "),a("p",[t._v("（1）网站调整（如改变网页目录结构）； （2）网页被移到一个新地址； （3）网页扩展名改变(如应用需要把.php改成.Html或.shtml)。 这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。")]),t._v(" "),a("p",[a("strong",[t._v("3、什么时候进行301或者302跳转呢？")])]),t._v(" "),a("p",[t._v("当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的。 清晰明确而言：使用301跳转的大概场景如下：")]),t._v(" "),a("ul",[a("li",[t._v("域名到期不想续费（或者发现了更适合网站的域名），想换个域名。")]),t._v(" "),a("li",[t._v("在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。")]),t._v(" "),a("li",[t._v("空间服务器不稳定，换空间的时候。")])]),t._v(" "),a("h2",{attrs:{id:"服务器处理请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务器处理请求"}},[t._v("#")]),t._v(" 服务器处理请求")]),t._v(" "),a("p",[t._v("​\t经过前面的重重步骤，我们终于将我们的http请求发送到了服务器这里，其实前面的重定向已经是到达服务器了，那么，服务器是如何处理我们的请求的呢？")]),t._v(" "),a("p",[t._v("​\t后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。")]),t._v(" "),a("p",[t._v("​\t一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。")]),t._v(" "),a("p",[t._v("如图所示：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/4/163c83c3e1eedb78~tplv-t2oaga2asx-watermark.awebp",alt:"img"}})]),t._v(" "),a("p",[t._v("补充：")]),t._v(" "),a("p",[t._v("1、"),a("strong",[t._v("什么是反向代理？")])]),t._v(" "),a("p",[t._v("客户端本来可以直接通过HTTP协议访问某网站应用服务器，网站管理员可以在中间加上一个Nginx，客户端请求Nginx，Nginx请求应用服务器，然后将结果返回给客户端，此时Nginx就是反向代理服务器。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/4/163c83c46b8db0af~tplv-t2oaga2asx-watermark.awebp",alt:"img"}})]),t._v(" "),a("h2",{attrs:{id:"服务器返回一个-http-响应"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务器返回一个-http-响应"}},[t._v("#")]),t._v(" 服务器返回一个 HTTP 响应")]),t._v(" "),a("p",[t._v("经过前面的6个步骤，服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTPP响应。 HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是：")]),t._v(" "),a("ul",[a("li",[t._v("状态行")]),t._v(" "),a("li",[t._v("响应头(Response Header)")]),t._v(" "),a("li",[t._v("空行")]),t._v(" "),a("li",[t._v("响应正文")])]),t._v(" "),a("div",{staticClass:"language-html extra-class"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[t._v("HTTP/1.1 200 OK\nDate: Sat, 31 Dec 2005 23:59:59 GMT\nContent-Type: text/html;charset=ISO-8859-1\nContent-Length: 122\n\n＜html＞\n＜head＞\n＜title＞http＜/title＞\n＜/head＞\n＜body＞\n＜!-- body goes here --＞\n＜/body＞\n＜/html＞\n\n复制代码\n")])])]),a("p",[a("strong",[t._v("状态行：")]),t._v(" 状态行由"),a("code",[t._v("协议版本")]),t._v("、数字形式的"),a("code",[t._v("状态代码")]),t._v("、及相应的"),a("code",[t._v("状态描述")]),t._v("，各元素之间以空格分隔。 格式: "),a("code",[t._v("HTTP-Version Status-Code Reason-Phrase CRLF")]),t._v(" 例如: "),a("code",[t._v("HTTP/1.1 200 OK \\r\\n")]),t._v(" | -协议版本：是用http1.0还是其他版本 | -状态描述：状态描述给出了关于状态代码的简短的文字描述。比如状态代码为200时的描述为 ok | -态代码：状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。如下")]),t._v(" "),a("p",[a("code",[t._v("1xx：")]),t._v("信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。")]),t._v(" "),a("ul",[a("li",[t._v("100 Continue")]),t._v(" "),a("li",[t._v("101 Switching Protocols")])]),t._v(" "),a("p",[a("code",[t._v("2xx：")]),t._v("成功状态码，表示服务器已成功接收到请求并进行处理。")]),t._v(" "),a("ul",[a("li",[t._v("200 OK 表示客户端请求成功")]),t._v(" "),a("li",[t._v("204 No Content 成功，但不返回任何实体的主体部分")]),t._v(" "),a("li",[t._v("206 Partial Content 成功执行了一个范围（Range）请求")])]),t._v(" "),a("p",[a("code",[t._v("3xx：")]),t._v(" 重定向状态码，表示服务器要求客户端重定向。")]),t._v(" "),a("ul",[a("li",[t._v("301 Moved Permanently 永久性重定向，响应报文的Location首部应该有该资源的新URL")]),t._v(" "),a("li",[t._v("302 Found 临时性重定向，响应报文的Location首部给出的URL用来临时定位资源")]),t._v(" "),a("li",[t._v("303 See Other 请求的资源存在着另一个URI，客户端应使用GET方法定向获取请求的资源")]),t._v(" "),a("li",[t._v("304 Not Modified 服务器内容没有更新，可以直接读取浏览器缓存")]),t._v(" "),a("li",[t._v("307 Temporary Redirect 临时重定向。与302 Found含义一样。302禁止POST变换为GET，但实际使用时并不一定，307则更多浏览器可能会遵循这一标准，但也依赖于浏览器具体实现")])]),t._v(" "),a("p",[a("code",[t._v("4xx：")]),t._v("客户端错误状态码，表示客户端的请求有非法内容。")]),t._v(" "),a("ul",[a("li",[t._v("400 Bad Request 表示客户端请求有语法错误，不能被服务器所理解")]),t._v(" "),a("li",[t._v("401 Unauthonzed 表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用")]),t._v(" "),a("li",[t._v("403 Forbidden 表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因")]),t._v(" "),a("li",[t._v("404 Not Found 请求的资源不存在，例如，输入了错误的URL")])]),t._v(" "),a("p",[a("code",[t._v("5xx")]),t._v("：服务器错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误。")]),t._v(" "),a("ul",[a("li",[t._v("500 Internel Server Error 表示服务器发生不可预期的错误，导致无法完成客户端的请求")]),t._v(" "),a("li",[t._v("503 Service Unavailable 表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常")])]),t._v(" "),a("p",[a("strong",[t._v("响应头：")])]),t._v(" "),a("p",[t._v("​\t响应头部：由关键字/值对组成，每行一对，关键字和值用英文冒号”:”分隔，典型的响应头有：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/4/163c83c3e27ba042~tplv-t2oaga2asx-watermark.awebp",alt:"img"}})]),t._v(" "),a("p",[a("strong",[t._v("响应正文")]),t._v(" ：")]),t._v(" "),a("p",[t._v("包含着我们需要的一些具体信息，比如cookie，html,image，后端返回的请求数据等等。这里需要注意，响应正文和响应头之间有一行空格，表示响应头的信息到空格为止，下图是fiddler抓到的请求正文，红色框中的：响应正文：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/4/163c83c3e4c33ac6~tplv-t2oaga2asx-watermark.awebp",alt:"img"}})]),t._v(" "),a("h2",{attrs:{id:"浏览器显示-html"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器显示-html"}},[t._v("#")]),t._v(" 浏览器显示 HTML")]),t._v(" "),a("blockquote",[a("p",[t._v("浏览器在收到HTML,CSS,JS文件后，它是如何把页面呈现到屏幕上的？下图对应的就是WebKit渲染的过程。")])]),t._v(" "),a("p",[a("strong",[t._v("构建dom树 -> 构建render树 -> 布局render树 -> 绘制render树")])]),t._v(" "),a("p",[t._v("渲染过程：")]),t._v(" "),a("p",[t._v("​\t浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。")]),t._v(" "),a("p",[t._v("​\t当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。因为JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。所以平时的代码中，js是放在html文档末尾的。")]),t._v(" "),a("p",[t._v("​\tJS的解析是由浏览器中的JS解析引擎完成的。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。")]),t._v(" "),a("p",[t._v("​\tJS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/4/163c83c3e5f0ccca~tplv-t2oaga2asx-watermark.awebp",alt:"img"}})]),t._v(" "),a("h2",{attrs:{id:"连接结束"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#连接结束"}},[t._v("#")]),t._v(" 连接结束")]),t._v(" "),a("p",[t._v("​\t现在的页面为了优化请求的耗时，默认都会开启持久连接（keep-alive），那么一个TCP连接确切关闭的时机，是这个tab标签页关闭的时候。这个关闭的过程就是著名的四次挥手。关闭是一个全双工的过程，发包的顺序的不一定的。一般来说是客户端主动发起的关闭，过程如下。")]),t._v(" "),a("p",[t._v("对于一个已经建立的连接，TCP使用改进的三次握手来释放连接（使用一个带有FIN附加标记的报文段）。TCP关闭连接的步骤如下：")]),t._v(" "),a("p",[t._v("第一步，当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。")]),t._v(" "),a("p",[t._v("第二步，主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。")]),t._v(" "),a("p",[t._v("第三步，主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。")]),t._v(" "),a("p",[t._v("第四步，主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。")]),t._v(" "),a("p",[t._v("补充：")]),t._v(" "),a("p",[t._v("为什么连接的时候是三次握手，关闭的时候却是四次握手？")]),t._v(" "),a("p",[t._v('答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。')]),t._v(" "),a("h1",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("​\t至此，整篇文章暂时到这里，文章内容大部分为参考网上信息，还有很多细节点需要去整理归纳，如有不足，希望多多指出！")]),t._v(" "),a("p",[t._v("参考文献：")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://link.juejin.cn?target=https%3A%2F%2Fxianyulaodi.github.io%2F2017%2F03%2F22%2F%E8%80%81%E7%94%9F%E5%B8%B8%E8%B0%88-%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%2F",target:"_blank",rel:"noopener noreferrer"}},[t._v("老生常谈-从输入url到页面展示到底发生了什么"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000006879700",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端经典面试题: 从输入URL到页面加载发生了什么？"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000013522717",target:"_blank",rel:"noopener noreferrer"}},[t._v("从输入url到页面展现发生了什么？"),a("OutboundLink")],1)]),t._v(" "),a("hr")])}),[],!1,null,null,null);e.default=v.exports}}]);