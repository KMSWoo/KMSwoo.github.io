(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{675:function(e,n,a){"use strict";a.r(n);var t=a(47),o=Object(t.a)({},(function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("起初我认为这是ES6或者Webpack的语法，但查阅相关API后并没有相关说明，通过进一步地搜索，才知道...")]),e._v(" "),a("p",[e._v("这是Node模块系统的约定和实现（Webpack打包工具是兼容node模块系统的，自然遵守相关规则），由于 webpack 等模块打包工具是兼容 node 的模块系统的，自然也会进行同样的处理流程。不同的是，它们支持更灵活的配置。比如在 webpack 里面，可以通过 alias 和 external 字段配置，实现对默认 import 逻辑的自定义。")]),e._v(" "),a("p",[e._v('当require/import 的模块不是核心模块，或"./"这样的相对路径，就会从当前package的node_modules开始找，找不到就到当前package的上一层node_modules里找。。直到找到全局的node_modules。')]),e._v(" "),a("p",[e._v("这样找到的是一个同名的文件夹，如果文件夹下有package.json,便根据main字段找到js文件，如果没有，则默认取当前文件夹下的index.js。")]),e._v(" "),a("p",[e._v("官网原文："),a("a",{attrs:{href:"https://nodejs.org/dist/latest-v8.x/docs/api/modules.html#modules_all_together",target:"_blank",rel:"noopener noreferrer"}},[e._v("链接"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("To get the exact filename that will be loaded when "),a("code",[e._v("require()")]),e._v(" is called, use the "),a("code",[e._v("require.resolve()")]),e._v(" function.")]),e._v(" "),a("p",[e._v("Putting together all of the above, here is the high-level algorithm in pseudocode of what "),a("code",[e._v("require.resolve()")]),e._v(" does:")]),e._v(" "),a("div",{staticClass:"language-txt extra-class"},[a("pre",{pre:!0,attrs:{class:"language-txt"}},[a("code",[e._v("require(X) from module at path Y\n1. If X is a core module,\n   a. return the core module\n   b. STOP\n2. If X begins with '/'\n   a. set Y to be the filesystem root\n3. If X begins with './' or '/' or '../'\n   a. LOAD_AS_FILE(Y + X)\n   b. LOAD_AS_DIRECTORY(Y + X)\n4. LOAD_NODE_MODULES(X, dirname(Y))\n5. THROW \"not found\"\n\nLOAD_AS_FILE(X)\n1. If X is a file, load X as JavaScript text.  STOP\n2. If X.js is a file, load X.js as JavaScript text.  STOP\n3. If X.json is a file, parse X.json to a JavaScript Object.  STOP\n4. If X.node is a file, load X.node as binary addon.  STOP\n\nLOAD_INDEX(X)\n1. If X/index.js is a file, load X/index.js as JavaScript text.  STOP\n2. If X/index.json is a file, parse X/index.json to a JavaScript object. STOP\n3. If X/index.node is a file, load X/index.node as binary addon.  STOP\n\nLOAD_AS_DIRECTORY(X)\n1. If X/package.json is a file,\n   a. Parse X/package.json, and look for \"main\" field.\n   b. let M = X + (json main field)\n   c. LOAD_AS_FILE(M)\n   d. LOAD_INDEX(M)\n2. LOAD_INDEX(X)\n\nLOAD_NODE_MODULES(X, START)\n1. let DIRS=NODE_MODULES_PATHS(START)\n2. for each DIR in DIRS:\n   a. LOAD_AS_FILE(DIR/X)\n   b. LOAD_AS_DIRECTORY(DIR/X)\n\nNODE_MODULES_PATHS(START)\n1. let PARTS = path split(START)\n2. let I = count of PARTS - 1\n3. let DIRS = []\n4. while I >= 0,\n   a. if PARTS[I] = \"node_modules\" CONTINUE\n   b. DIR = path join(PARTS[0 .. I] + \"node_modules\")\n   c. DIRS = DIRS + DIR\n   d. let I = I - 1\n5. return DIRS\n")])])]),a("hr")])}),[],!1,null,null,null);n.default=o.exports}}]);