(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{710:function(t,a,s){"use strict";s.r(a);var e=s(47),_=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("JavaScript的面向对象编程和大多数其他语言如Java、C#的面向对象编程都不太一样。JavaScript 是动态的，本身不提供一个 "),s("code",[t._v("class")]),t._v(" 的实现。即便是在 ES2015/ES6 中引入了 "),s("code",[t._v("class")]),t._v(" 关键字，但那也只是语法糖，JavaScript 仍然是基于原型的。")]),t._v(" "),s("h2",{attrs:{id:"区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[t._v("#")]),t._v(" 区别")]),t._v(" "),s("p",[t._v("在传统的面向对象语言中：")]),t._v(" "),s("ol",[s("li",[t._v("类：是创建对象的模板")]),t._v(" "),s("li",[t._v("实例：根据模板创建出来的对象")])]),t._v(" "),s("p",[t._v("而JavaScript不区分类和实例的概念，它没有“Class”的概念，所有对象都是实例，而是通过原型（prototype）来实现面向对象编程。")]),t._v(" "),s("h2",{attrs:{id:"什么是prototype"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是prototype"}},[t._v("#")]),t._v(" 什么是prototype")]),t._v(" "),s("p",[t._v("在这之前，首先要弄清楚几个概念：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("函数")]),t._v("：简单来说函数就是一个代码片段，可以接收特定值执行特定步骤并且返回一个值。在JS中，函数是"),s("strong",[t._v("头等("),s("strong",[t._v("first-class")]),t._v(")"),s("strong",[t._v("对象，因为它们可以像任何其他")]),t._v("对象")]),t._v("一样具有属性和方法。它们与其他对象的区别在于函数可以被调用。简而言之，它们是"),s("code",[t._v("Function")]),t._v("对象。")]),t._v(" "),s("li",[t._v("构造函数：当一个函数通过new关键字调用的时候才是构造函数")])]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("Human")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//定义一个函数，它只是一个普通的函数")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" h1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Human")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//它现在是一个构造函数。因为通过new关键字调用了它")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//创建了一个Human构造函数的实例 h1")]),t._v("\n")])])]),s("p",[t._v("当创建一个函数，就会按照特定的规则为这个函数创建一个 "),s("strong",[t._v("prototype 属性")]),t._v("（"),s("strong",[t._v("指向原型对象")]),t._v("）。默认情况下，所有原型对象自动获得一个名为 constructor 的属性，指回与之关联的构造函数。")]),t._v(" "),s("p",[s("code",[t._v("prototype")]),t._v("属性是"),s("strong",[t._v("函数独有")]),t._v("的属性，它设计之初就是为了实现继承，让由特定函数创建的所有实例共享属性和方法，也可以说是让某一个构造函数实例化的所有对象可以找到公共的方法和属性。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Human")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("msg "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"我是原型属性，所有实例都能访问到！"')]),t._v("\n")])])]),s("h2",{attrs:{id:"什么是-proto"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是-proto"}},[t._v("#")]),t._v(" 什么是"),s("code",[t._v("__proto__")])]),t._v(" "),s("p",[s("code",[t._v("__proto__")]),t._v("属性是"),s("strong",[t._v("对象独有")]),t._v("的属性，且每个对象都有，它从一个对象指向该对象的原型对象。因为函数也是对象，所以函数既有prototype属性，也有"),s("code",[t._v("__proto__")]),t._v("属性")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[t._v("h1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__proto__ "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Human")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\n")])])]),s("p",[s("code",[t._v("__proto__")]),t._v("通常称为隐式原型，"),s("code",[t._v("prototype")]),t._v("通常称为显式原型，那我们可以说一个对象的隐式原型指向了该对象的构造函数的显式原型。那么我们在显式原型上定义的属性方法，通过隐式原型传递给了构造函数的实例。这样一来实例就能很容易的访问到构造函数原型上的方法和属性了。")]),t._v(" "),s("h2",{attrs:{id:"什么是原型链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是原型链"}},[t._v("#")]),t._v(" 什么是原型链")]),t._v(" "),s("p",[t._v("既然"),s("code",[t._v("__proto__")]),t._v("是每个对象都有的，那么Human.prototype也是对象，那么：")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Human")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__proto__ "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//true")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__proto__ "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//true")]),t._v("\n")])])]),s("p",[t._v("构造函数的原型对象上的隐式原型对象指向了Object的原型对象。那么Human的原型对象就继承了Object的原型对象。由此我们可以验证一个结论，万物继承自Object.prototype。")]),t._v(" "),s("p",[t._v("这就是为什么实例对象可以使用Object原型对象上的"),s("code",[t._v("toString")]),t._v("方法的原因。当我们调用"),s("code",[t._v("h1.toString()")]),t._v("的时候，先在"),s("code",[t._v("h1")]),t._v("对象本身寻找，没有找到则通过"),s("code",[t._v("h1.__proto__")]),t._v("找到了原型对象"),s("code",[t._v("Human.prototype")]),t._v("，也没有找到，又通过"),s("code",[t._v("Human.prototype.__proto__")]),t._v("找到了上一层原型对象Object.prototype。在这一层找到了toString方法。返回该方法供"),s("code",[t._v("h1")]),t._v("使用。\n当然如果找到Object.prototype上也没找到，就在"),s("code",[t._v("Object.prototype.__proto__")]),t._v("中寻找，但是"),s("code",[t._v("Object.prototype.__proto__ === null")]),t._v("所以就返回undefined。这就是为什么当访问对象中一个不存在的属性时，返回undefined了。")]),t._v(" "),s("p",[t._v("而这一层一层的prototype就像一条链子一样，就是原型链了。")]),t._v(" "),s("hr")])}),[],!1,null,null,null);a.default=_.exports}}]);