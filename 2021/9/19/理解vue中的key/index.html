<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>理解vue中的key</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" type="image/png" href="/favicons/favicon.png">
    <link rel="stylesheet" href="https://fonts.font.im/css?family=Lobster|Satisfy">
    <link rel="preload" crossorigin="anonymous" href="//at.alicdn.com/t/font_2949371_6nhphjuvnzc.woff2" as="font" type="font/woff2">
    <link rel="stylesheet" href="//at.alicdn.com/t/font_2949371_6nhphjuvnzc.css">
    <link rel="preload" crossorigin="anonymous" href="//at.alicdn.com/t/font_2953551_u612koyhj6.woff2" as="font" type="font/woff2">
    <link rel="stylesheet" href="//at.alicdn.com/t/font_2953551_u612koyhj6.css">
    <script charset="utf-8" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async="true"></script>
    <meta name="description" content="Just for fun!">
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <link rel="preload" href="/assets/css/0.styles.709f0a23.css" as="style"><link rel="preload" href="/assets/js/app.f6b2750d.js" as="script"><link rel="preload" href="/assets/js/6.992087fc.js" as="script"><link rel="preload" href="/assets/js/1.bd8257ab.js" as="script"><link rel="preload" href="/assets/js/88.a27b91e6.js" as="script"><link rel="prefetch" href="/assets/js/10.a4ac7942.js"><link rel="prefetch" href="/assets/js/100.334f7041.js"><link rel="prefetch" href="/assets/js/101.fbd706a6.js"><link rel="prefetch" href="/assets/js/102.928bd9cf.js"><link rel="prefetch" href="/assets/js/103.0e507560.js"><link rel="prefetch" href="/assets/js/104.677d6026.js"><link rel="prefetch" href="/assets/js/11.a88e960f.js"><link rel="prefetch" href="/assets/js/12.82f24d68.js"><link rel="prefetch" href="/assets/js/13.aa0330ff.js"><link rel="prefetch" href="/assets/js/14.c5724fbc.js"><link rel="prefetch" href="/assets/js/15.c41a9191.js"><link rel="prefetch" href="/assets/js/16.b14c2bfe.js"><link rel="prefetch" href="/assets/js/17.6bd551a7.js"><link rel="prefetch" href="/assets/js/18.4f1f5177.js"><link rel="prefetch" href="/assets/js/19.f06a202c.js"><link rel="prefetch" href="/assets/js/20.907e26c8.js"><link rel="prefetch" href="/assets/js/21.dfdb6fc0.js"><link rel="prefetch" href="/assets/js/22.3c22b8fb.js"><link rel="prefetch" href="/assets/js/23.ba3747ff.js"><link rel="prefetch" href="/assets/js/24.07436c85.js"><link rel="prefetch" href="/assets/js/25.f117c5b2.js"><link rel="prefetch" href="/assets/js/26.fd9683ac.js"><link rel="prefetch" href="/assets/js/27.90ad260b.js"><link rel="prefetch" href="/assets/js/28.e5a99905.js"><link rel="prefetch" href="/assets/js/29.7f97fe08.js"><link rel="prefetch" href="/assets/js/3.6131e7eb.js"><link rel="prefetch" href="/assets/js/30.c5ed064d.js"><link rel="prefetch" href="/assets/js/31.c461afd1.js"><link rel="prefetch" href="/assets/js/32.8eebdde2.js"><link rel="prefetch" href="/assets/js/33.03d4eff8.js"><link rel="prefetch" href="/assets/js/34.3928d533.js"><link rel="prefetch" href="/assets/js/35.ef8efb45.js"><link rel="prefetch" href="/assets/js/36.83819fce.js"><link rel="prefetch" href="/assets/js/37.6d59eda5.js"><link rel="prefetch" href="/assets/js/38.a4afb281.js"><link rel="prefetch" href="/assets/js/39.43918783.js"><link rel="prefetch" href="/assets/js/4.b19c5430.js"><link rel="prefetch" href="/assets/js/40.d580eb3a.js"><link rel="prefetch" href="/assets/js/41.b577c732.js"><link rel="prefetch" href="/assets/js/42.981612e9.js"><link rel="prefetch" href="/assets/js/43.2885ecf0.js"><link rel="prefetch" href="/assets/js/44.22787400.js"><link rel="prefetch" href="/assets/js/45.7723d406.js"><link rel="prefetch" href="/assets/js/46.d928e9cd.js"><link rel="prefetch" href="/assets/js/47.f85996d5.js"><link rel="prefetch" href="/assets/js/48.6c8717ee.js"><link rel="prefetch" href="/assets/js/49.3c5e8dd4.js"><link rel="prefetch" href="/assets/js/5.2622ab97.js"><link rel="prefetch" href="/assets/js/50.92a73ca7.js"><link rel="prefetch" href="/assets/js/51.80a48043.js"><link rel="prefetch" href="/assets/js/52.c9bf257c.js"><link rel="prefetch" href="/assets/js/53.018ac1d8.js"><link rel="prefetch" href="/assets/js/54.a89e7420.js"><link rel="prefetch" href="/assets/js/55.d3aaddea.js"><link rel="prefetch" href="/assets/js/56.e9a7f02b.js"><link rel="prefetch" href="/assets/js/57.3f40c7b1.js"><link rel="prefetch" href="/assets/js/58.ad13bdb8.js"><link rel="prefetch" href="/assets/js/59.e269e085.js"><link rel="prefetch" href="/assets/js/60.0e9131e2.js"><link rel="prefetch" href="/assets/js/61.cc482820.js"><link rel="prefetch" href="/assets/js/62.a2e07666.js"><link rel="prefetch" href="/assets/js/63.7ddbd27f.js"><link rel="prefetch" href="/assets/js/64.01d97934.js"><link rel="prefetch" href="/assets/js/65.ec223303.js"><link rel="prefetch" href="/assets/js/66.1e481a1f.js"><link rel="prefetch" href="/assets/js/67.464c9e1a.js"><link rel="prefetch" href="/assets/js/68.de1774cb.js"><link rel="prefetch" href="/assets/js/69.b9d57c0d.js"><link rel="prefetch" href="/assets/js/7.74b5cc39.js"><link rel="prefetch" href="/assets/js/70.3711e0ce.js"><link rel="prefetch" href="/assets/js/71.767e8f35.js"><link rel="prefetch" href="/assets/js/72.a53a1b45.js"><link rel="prefetch" href="/assets/js/73.bee69c94.js"><link rel="prefetch" href="/assets/js/74.7a7adeff.js"><link rel="prefetch" href="/assets/js/75.6c3a8090.js"><link rel="prefetch" href="/assets/js/76.d1ae5729.js"><link rel="prefetch" href="/assets/js/77.5c3a3781.js"><link rel="prefetch" href="/assets/js/78.00f78c3d.js"><link rel="prefetch" href="/assets/js/79.7411c161.js"><link rel="prefetch" href="/assets/js/8.3a17ca06.js"><link rel="prefetch" href="/assets/js/80.e68cc1e1.js"><link rel="prefetch" href="/assets/js/81.f6a47abe.js"><link rel="prefetch" href="/assets/js/82.3be4b911.js"><link rel="prefetch" href="/assets/js/83.a6f2eb0b.js"><link rel="prefetch" href="/assets/js/84.50cf6623.js"><link rel="prefetch" href="/assets/js/85.e398d0f1.js"><link rel="prefetch" href="/assets/js/86.c4379b40.js"><link rel="prefetch" href="/assets/js/87.d388ea25.js"><link rel="prefetch" href="/assets/js/89.4bfb06f1.js"><link rel="prefetch" href="/assets/js/9.9dcd8d7c.js"><link rel="prefetch" href="/assets/js/90.a020fc84.js"><link rel="prefetch" href="/assets/js/91.f8555e11.js"><link rel="prefetch" href="/assets/js/92.c390150d.js"><link rel="prefetch" href="/assets/js/93.3d51d66e.js"><link rel="prefetch" href="/assets/js/94.583e865f.js"><link rel="prefetch" href="/assets/js/95.a3c88640.js"><link rel="prefetch" href="/assets/js/96.2f0f983e.js"><link rel="prefetch" href="/assets/js/97.dfd7a5e2.js"><link rel="prefetch" href="/assets/js/98.8c9c7dd6.js"><link rel="prefetch" href="/assets/js/99.c4482f1c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.709f0a23.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="animate__animated animate__fadeIn animate__slow container"><div class="header-wrap" data-v-bc840c6a><div class="header page" data-v-bc840c6a><div class="left" data-v-bc840c6a><div class="head-title" data-v-bc840c6a></div> <div class="nav" data-v-bc840c6a></div></div> <div class="right" data-v-bc840c6a><div class="search-box" data-v-bc840c6a><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div></div></div> <div class="page post-page"><div class="title"><div class="post-title">理解vue中的key</div></div> <div class="info"><div class="tags"><a class="tag" data-v-5095c9bc>Vue</a></div> <div class="author">KMS Woo</div> <div class="date">2021-9-19</div> <div class="count" style="display:;"><span id="busuanzi_value_page_pv"></span> <span>views</span></div></div> <div class="post-content"><div class="content__default"><p><code>key</code> 是特殊的 attribute ，主要用做 Vue 的虚拟 DOM 算法的提示，以在比对新旧节点组时辨识 VNodes。</p> <p>就目前所了解的情况，key的作用有以下这些。</p> <ul><li>v-for遍历时，用id，uuid之类作为key，唯一标识节点加速虚拟DOM渲染</li> <li>响应式系统没有监听到的数据，用+new Date()生成的时间戳作为key，手动强制触发重新渲染</li></ul> <p>场景一大同小异司空见惯，场景二是下面这样的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>div <span class="token operator">:</span>key<span class="token operator">=</span><span class="token string">&quot;rerender&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>Hello Vue<span class="token punctuation">.</span>js <span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>complexComponent <span class="token operator">:</span>propObj<span class="token operator">=</span><span class="token string">&quot;propObj&quot;</span> <span class="token operator">:</span>propArr<span class="token operator">=</span><span class="token string">&quot;propArr&quot;</span> <span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>complexComponent<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>

<span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>rerender <span class="token operator">=</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
复制代码
</code></pre></div><p>那么vue中key的相关知识点到底是怎样的呢？</p> <ul><li>官方API知识点</li> <li>上面2个使用场景背后的原理是什么？</li> <li>除key外，还有其它强制更新DOM的方法吗？</li> <li>参考资料</li></ul> <h3 id="官方api知识点"><a href="#官方api知识点" class="header-anchor">#</a> 官方API知识点</h3> <ul><li>在Vue.js中，key是6个特殊属性key, ref, is, slot, slot-scope, scope其中之一。</li> <li>key的值可以是number，也可以是string。</li> <li>key主要作用于Vue的virtual DOM算法，在diff new nodes list和old nodes list时，作为识别VNode的一个线索。</li> <li>如果不用key，Vue会用一种算法：最小化element的移动，并且会尝试尽最大程度在同适当的地方对相同类型的element，做patch或者reuse。</li> <li>如果使用了key，Vue会根据keys的顺序记录element，<strong>曾经拥有了key的element如果不再出现的话，会被直接remove或者destoryed。</strong></li> <li>拥有同一个parent的children必须有unique keys。重复的key的导致render error。</li></ul> <h4 id="最常用的用法一-v-for"><a href="#最常用的用法一-v-for" class="header-anchor">#</a> 最常用的用法一：v-for</h4> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item in items<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item.id<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h4 id="最常用的用法二-强制替换element或者component"><a href="#最常用的用法二-强制替换element或者component" class="header-anchor">#</a> 最常用的用法二：强制替换element或者component</h4> <ul><li>触发组件的lifecycle</li> <li>触发transition</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;transition&gt;
  &lt;span :key=&quot;text&quot;&gt;{{ text }}&lt;/span&gt;
&lt;/transition&gt;
复制代码
</code></pre></div><p>text发生变化时，<code>&lt;span&gt;</code>会被replaced，而不会patched，因此transition会被触发。 我的理解： <strong>text变化时，span的key发生了变化，也就是说曾经拥有了旧key的span不再出现了，当拥有新值的text作为key时，拥有了新key的span出现了，那么旧key span会被移除，旧transition也会移除，新key span触发渲染，新transition触发。</strong></p> <h3 id="上面2个使用场景背后的原理是什么"><a href="#上面2个使用场景背后的原理是什么" class="header-anchor">#</a> 上面2个使用场景背后的原理是什么？</h3> <p>结合官方API的知识点，现在再来回顾文章开头提出的场景。</p> <h4 id="场景一-v-for遍历时-用id-uuid之类作为key-唯一标识节点加速虚拟dom渲染"><a href="#场景一-v-for遍历时-用id-uuid之类作为key-唯一标识节点加速虚拟dom渲染" class="header-anchor">#</a> 场景一：v-for遍历时，用id，uuid之类作为key，唯一标识节点加速虚拟DOM渲染</h4> <p>答案：</p> <ul><li>如果不用key，Vue会用一种算法：最小化element的移动，并且会尝试尽最大程度在同适当的地方对相同类型的element，做patch或者reuse。</li> <li>如果使用了key，Vue会根据keys的顺序记录element，<strong>曾经拥有了key的element如果不再出现的话，会被直接remove或者destoryed。</strong></li></ul> <h4 id="场景二-响应式系统没有监听到的数据-用-new-date-生成的时间戳作为key-手动强制触发重新渲染"><a href="#场景二-响应式系统没有监听到的数据-用-new-date-生成的时间戳作为key-手动强制触发重新渲染" class="header-anchor">#</a> 场景二：响应式系统没有监听到的数据，用+new Date()生成的时间戳作为key，手动强制触发重新渲染</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>div <span class="token operator">:</span>key<span class="token operator">=</span><span class="token string">&quot;rerender&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>Hello Vue<span class="token punctuation">.</span>js <span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>complexComponent <span class="token operator">:</span>propObj<span class="token operator">=</span><span class="token string">&quot;propObj&quot;</span> <span class="token operator">:</span>propArr<span class="token operator">=</span><span class="token string">&quot;propArr&quot;</span> <span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>complexComponent<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>

<span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>rerender <span class="token operator">=</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
复制代码
</code></pre></div><p>答案：</p> <ul><li>如果使用了key，Vue会根据keys的顺序记录element，<strong>曾经拥有了key的element如果不再出现的话，会被直接remove或者destoryed。</strong></li> <li>refresh方法调用后，包含了span和complexComponent的div的key发生了变化，也就是说曾经拥有了旧key的div不再出现了，当拥有新值的rerender作为key时，拥有了新key的div出现了，那么旧key div会被移除，旧span和complexComponent也会移除，新key div触发渲染，新span，<strong>带着父组件新propObj和propArr的新complexComponent渲染。</strong></li></ul> <p>思考：</p> <ol><li>为什么要叫propObj和propArr？</li> <li><strong>带着父组件新propObj和propArr的新complexComponent渲染。</strong> 为什么要加粗？</li></ol> <p>由于Vue.js的obj和arr存在无法检测到数据变化的情况，obj是属性的新增和删除（原因是新增和删除都没有触发setter，watcher未告诉外界更新），arr则是数组内元素重新赋值或者修改length属性（原因是没有使用改变数组本身的方法，没有触发数组原型链拦截器，watcher未告诉外界更新）。 所以！通过赋予新key的方式，移除旧key div，渲染新key div，propObj和propArr在complexComponent组件内会重新触发一次生命周期，做一次重新渲染。**此时父组件的propObj和propArr js变量其实已经获取到新值了，只是没有触发DOM也好，VNode也好的重新渲染。**需要通过刷新key去force update，说到forceUpdate，可以通过$forceUpdate()去手动强制更新DOM。</p> <h3 id="除key外-还有其它强制更新dom的方法吗"><a href="#除key外-还有其它强制更新dom的方法吗" class="header-anchor">#</a> 除key外，还有其它强制更新DOM的方法吗？</h3> <p>场景：父组件修改传递给子组件的数据，数组数据的更新没有按照this.$set去更新。该怎么办？</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span>productImages<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">product</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>product<span class="token punctuation">.</span>productId <span class="token keyword">in</span> <span class="token keyword">this</span><span class="token punctuation">.</span>productsState<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    product<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>productsState<span class="token punctuation">[</span>product<span class="token punctuation">.</span>productId<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
复制代码
</code></pre></div><p><strong>不使用this.$set去赋值数据的不能rerender的原因是什么？</strong> 在Vue.js中，对Array的变化侦测是通过拦截原型的方式实现的。也就通过对push，pop，shift，unshift，splice，sort，reverse，fill，copyWithin去改变数组自身内容的方法做拦截，从而响应。而<code>product.status = this.productsState[product.productId];</code>没有触发任何改变数组自身的被监听的方法，因此不会rerender。</p> <ul><li>刷新组件的key</li> <li>$forceUpdate方法</li></ul> <h4 id="刷新组件的key"><a href="#刷新组件的key" class="header-anchor">#</a> 刷新组件的key</h4> <h5 id="_1-这个key加在什么地方比较好"><a href="#_1-这个key加在什么地方比较好" class="header-anchor">#</a> 1.这个key加在什么地方比较好？</h5> <p>加在this.productImages的父元素上就好。 若不涉及数据传递，也可以直接加在需要更新的element上。</p> <h5 id="_2-用什么做key值"><a href="#_2-用什么做key值" class="header-anchor">#</a> 2.用什么做key值？</h5> <p>现在是粗暴的+new Date()时间戳做key值的。 也可以用双向绑定的值作为key值，保证新旧key值不同就行。</p> <h5 id="_3-key的原理是什么"><a href="#_3-key的原理是什么" class="header-anchor">#</a> 3.key的原理是什么？</h5> <p>vue.js的虚拟DOM算法，在更新vNode时，需要从旧vNode列表中查找与新vNode节点相同的vNode进行更新，如果这个过程设置了属性key，过程就会快很多。 其他具体见上文。</p> <h4 id="forceupdate方法"><a href="#forceupdate方法" class="header-anchor">#</a> $forceUpdate方法</h4> <p><strong>只能在父组件调用这个方法，手动通知vue实例重新渲染。</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// $forceUpdate源码</span>
<span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$forceUpdate</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> vm<span class="token operator">:</span> Component <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_watcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vm<span class="token punctuation">.</span>_watcher<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// update源码</span>
<span class="token comment">/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */</span>
<span class="token function">update</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* istanbul ignore else */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>lazy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>dirty <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sync<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">queueWatcher</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="_1-forceupdate可以更新的原理分析"><a href="#_1-forceupdate可以更新的原理分析" class="header-anchor">#</a> 1.$forceUpdate可以更新的原理分析</h5> <p><code>product.status = this.productsState[product.productId];</code>以后，<strong>其实此时dep已经发生变化了</strong>，但是Vue.js数组响应式的实现由于是拦截原型链方法的方式，没有检测到这个变化，所以不会自动rerender，没有触发update。因此我们<strong>通过$forceUpdate的方式，调用包含dep的watcher上的update方法，从而做到rerender</strong>。</p> <h5 id="_2-可以在子组件监听事件-父组件发送事件然后只刷新子组件吗"><a href="#_2-可以在子组件监听事件-父组件发送事件然后只刷新子组件吗" class="header-anchor">#</a> 2.可以在子组件监听事件，父组件发送事件然后只刷新子组件吗？</h5> <p>不可以。 因为dep是父组件的watcher和dep，并不是子组件，是父组件的this.productImages没有被检测到并实时更新，并不是子组件的问题。</p> <hr></div></div></div> <div class="footer-wrap" data-v-e2e64d12><div class="footer page" data-v-e2e64d12><div class="count" data-v-e2e64d12>
      本站总访问量<span id="busuanzi_value_site_pv" data-v-e2e64d12></span>次
      本站访客数<span id="busuanzi_value_site_uv" data-v-e2e64d12></span>人次
      本文总阅读量<span id="busuanzi_value_page_pv" data-v-e2e64d12></span>次
    </div> <div class="link" data-v-e2e64d12><a href="http://www.aaronsw.com/" target="_blank" data-v-e2e64d12>Aaron Swartz</a><a href="https://www.cnblogs.com/rubylouvre/" target="_blank" data-v-e2e64d12>司徒正美</a></div> <div class="contact" data-v-e2e64d12><a href="https://github.com/KMSWoo" target="_blank" data-v-e2e64d12><span class="iconfont icon-github" data-v-e2e64d12></span></a> <a href="mailto:wayneincode@gmail.com" data-v-e2e64d12><span class="iconfont icon-youjian" data-v-e2e64d12></span></a></div></div></div></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.f6b2750d.js" defer></script><script src="/assets/js/6.992087fc.js" defer></script><script src="/assets/js/1.bd8257ab.js" defer></script><script src="/assets/js/88.a27b91e6.js" defer></script>
  </body>
</html>
